/* Include the approperiate API for reference, must install libraries if not available 
 command like (debian): sudo apt-get install python3.X-dev */

#include <Python.h>

typedef struct {
    PyObject_HEAD
    int block1[2];
    int block2[2];
} MyBuffer;

static int MyBuffer_getbuffer(MyBuffer* self, Py_buffer* view, int flags) {
    if (view == NULL) {
        PyErr_SetString(PyExc_ValueError, "NULL view in getbuffer");
        return -1;
    }

    view->obj = (PyObject*)self;
    view->buf = &self->block1;  // Start of the buffer
    view->len = 4 * sizeof(int);  // Total size of the buffer (4 integers)
    view->readonly = 0;
    view->itemsize = sizeof(int);  // Size of a single item in the buffer
    view->format = "i";  // Integer format
    view->ndim = 2;  // Number of dimensions

    static Py_ssize_t shape[2] = {2, 2};
    view->shape = shape;

    static Py_ssize_t strides[2] = {2 * sizeof(int), sizeof(int)};
    view->strides = strides;

    view->suboffsets = NULL;  // No suboffsets

    Py_INCREF(self);  // Increase reference count
    return 0;
}

static PyBufferProcs MyBuffer_as_buffer = {
    (getbufferproc)MyBuffer_getbuffer,
    (releasebufferproc)NULL,  // We don't need to do anything to release the buffer
};

static PyTypeObject MyBufferType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "MyBuffer",              /* tp_name */
    sizeof(MyBuffer),        /* tp_basicsize */
    0,                       /* tp_itemsize */
    NULL,                       /* tp_dealloc */
    0,                       /* tp_vectorcall_offset */
    NULL,                       /* tp_getattr */
    NULL,                       /* tp_setattr */
    NULL,                       /* tp_as_async */
    NULL,                       /* tp_repr */
    NULL,                       /* tp_as_number */
    NULL,                       /* tp_as_sequence */
    NULL,                       /* tp_as_mapping */
    NULL,                       /* tp_hash  */
    NULL,                       /* tp_call */
    NULL,                       /* tp_str */
    NULL,                       /* tp_getattro */
    NULL,                       /* tp_setattro */
    &MyBuffer_as_buffer,     /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,      /* tp_flags */
    "MyBuffer objects",      /* tp_doc */
};

/* provide a means to print the non-contigous buffer */
void print_buffer(Py_buffer *view) {
    int *buf = (int*)view->buf;
    for (int i = 0; i < view->shape[0]; i++) {
        for (int j = 0; j < view->shape[1]; j++) {
            int *item = (int*)((char*)buf + i * view->strides[0] + j * view->strides[1]);
            printf("%d ", *item);
        }
        printf("\n");
    }
}



// The function we want to expose to Python
static PyObject* vulnerable_function(PyObject* self, PyObject* args)
{
    /* create a non-contigous buffer so that we can access the vulnerable code */
    MyBuffer non_congigous_buf;
    Py_buffer src_view;
    MyBuffer_getbuffer(&non_congigous_buf, &src_view, 0);
    print_buffer(&src_view);

    printf("End of function, returning!\n");
    Py_RETURN_NONE;
    return 0;
}

// Define a method table actually exposing the function itself
static PyMethodDef VulnerableMethods[] = {
    {"vulnerable_function",  vulnerable_function, METH_VARARGS, "Demonstrate Abstract.c vulnerability'"},
    {NULL, NULL, 0, NULL}
};

// Create and define the module
static struct PyModuleDef vulnerablemodule = {
    PyModuleDef_HEAD_INIT,
    "vulnerable_function",
    NULL,
    -1,
    VulnerableMethods
};

// Export the function so Python can call it
PyMODINIT_FUNC
PyInit_poc(void)
{
    return PyModule_Create(&vulnerablemodule);
}
